#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import re
import datetime
import time

# torque commands
qstat_path = '/usr/local/torque/bin/qstat'
qstat = [qstat_path, '-f', '-1' ]
pbsnodes_path = '/usr/local/torque/bin/pbsnodes'
pbsnodes = [pbsnodes_path, '-a' ]

job_state = {
    'C': "Completed",
    'E': "Exiting",
    'H': "on Hold",
    'Q': "Queued",
    'R': "Running",
    'T': "Moved",
    'W': "--",
    'S': "Suspend",
}

def get_torque_job_info():
    jobs = {}
    present = datetime.datetime.now()

    #qstat -f -1でジョブ情報を取得し、２次元dictに詰める
    #jobs['jobid'][{"key": value, "key": value, ...}]
    #with open('qstat-f.job.all', 'r') as pjob:
    #    for jinfo in pjob:
    with subprocess.Popen(qstat, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as pjob:
        for jinfo in pjob.stdout:
    
            if re.match('Job Id:', jinfo):
                # a job informations begin here
                jid = re.search(r'^Job Id:\s*(\d+)\.', jinfo).group(1)
                jobs[jid] = {}
                jobs[jid]['JID'] = jid
                continue

            if re.search(' = ', jinfo):
                (jkey, jval) = jinfo.split(' = ')
                jkey = re.sub(r'\s', '', jkey)
                jobs[jid][jkey] = jval.rstrip()
            
    # ジョブごとに情報を追加
    for jid in jobs.keys():
        # ジョブ開始時間をjobs[jid]['rec_end']に登録する。
        if 'Execution_Time' in jobs[jid]:
            # 実行開始前(State: W)のジョブ。
            # 実行開始時間はqstat -fのExectiton_Timeから取得できる。
            # ex. "Tue Mar 15 23:59:50 2016"
            jobs[jid]['rec_begin'] = datetime.datetime.strptime(jobs[jid]['Execution_Time'], "%a %b %d %H:%M:%S %Y")
        elif 'start_time' in jobs[jid]: 
            # 実行中(State: R)、実行終了(State: C)のジョブ。
            # 実行開始時間はqstat -fのstart_timeから取得できる。
            # フォーマットはExecution_Timeに同じ。
            jobs[jid]['rec_begin'] = datetime.datetime.strptime(jobs[jid]['start_time'], "%a %b %d %H:%M:%S %Y")
        else:
            # ここに来るケースあるかしら？
            jobs[jid]['rec_begin'] = present;

        # ジョブ終了時間をjobs[jid]['rec_end']に登録する。
        # ジョブ開始時間 + Resource_List.walltime
        (wt_h, wt_m, wt_s) = jobs[jid]['Resource_List.walltime'].split(':')
        jobs[jid]['rec_end'] = jobs[jid]['rec_begin'] + datetime.timedelta(hours=int(wt_h), minutes=int(wt_m), seconds=int(wt_s))

        # タイトル、チャンネル番号を登録する
        (jobs[jid]['channel'], jobs[jid]['title']) = jobs[jid]['Job_Name'].split('.', 1)
        jobs[jid]['channel'] = re.sub('^ch[Bd]', '', jobs[jid]['channel'])

        # qstatのjob_stateをわかりやすい表記に
        jobs[jid]['record_state'] = job_state[jobs[jid]['job_state']]

        # 録画開始からの経過時間を登録する
        if jobs[jid]['job_state'] == 'R':
            jobs[jid]['elapse'] = present - jobs[jid]['rec_begin']
        elif jobs[jid]['job_state'] == 'C':
            (wt_h, wt_m, wt_s) = jobs[jid]['Resource_List.walltime'].split(':')
            jobs[jid]['elapse'] = datetime.timedelta(hours=int(wt_h), minutes=int(wt_m), seconds=int(wt_s))

        # 実行ホスト名の末尾'/0'を削除。
        if jobs[jid].get('exec_host'):
            jobs[jid]['exec_host'] = re.sub('/.*$', '', jobs[jid]['exec_host'])

    job_array = [jobs[x] for x in sorted(jobs.keys())]
    job_array = sorted(job_array, key=lambda j: j['rec_begin'])

    return job_array


def get_queue_info():
    nodes = {}
    queue_info = {}

    # pbsnodes -qの出力から以下の情報を取得する。
    # ノード名
    # properties: そのノードの所属するキュー名
    # np:         チューナー数
    # state:      ノードの状態
    with subprocess.Popen(pbsnodes, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as pnodes:
        for ninfo in pnodes.stdout:
            if re.match(r'^\S+', ninfo):
                # a node informations begin here
                n = re.search(r'^(\S+)', ninfo).group(1)
                nodes[n] = {}
                nodes[n]['NODENAME'] = n
                continue
            if re.match(r'^\s+(state|np|properties) = \S+', ninfo):
                (key, value) = re.search(r'(state|np|properties) = (\S+)', ninfo).group(1, 2)
                nodes[n][key] = value

    # キューごとに、そのキューに所属するノードとチャンネル数を集計する。
    # {properties: {NODENAME: np}}
    for node in nodes.values():
        if re.search(r'(offline|down)', node['state']):
            # 稼動状態にないノードは除外
            continue

        if not node['properties'] in queue_info:
            queue_info[node['properties']] = {}

        queue_info[node['properties']][node['NODENAME']] = node['np']

    return queue_info

job_array = get_torque_job_info()
for j in job_array:
    print('{0:5s} {1:>3s} {2:20s} {3} {4} {5}'.format(
    j['JID'], 
    j['channel'], 
    j['title'], 
    j['rec_begin'], 
    j['Resource_List.walltime'], 
    j['euser'],
    ))


# 確認(DEBUG)
#job_array = get_torque_job_info()
#for j in job_array:
#    for jkey in sorted(j.keys()):
#        print(jkey, ":", j[jkey])
#
#    print()

#queue_info = get_queue_info()
#for queue in queue_info.keys():
#    print(queue)
#    for v in queue_info[queue]:
#        print('    {0}  {1}'.format(v, queue_info[queue][v]))
