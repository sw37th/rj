#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import re
import datetime
import time

# torque commands
qstat_path = '/usr/local/torque/bin/qstat'
qstat = [qstat_path, '-f', '-1' ]
pbsnodes_path = '/usr/local/torque/bin/pbsnodes'
pbsnodes = [pbsnodes_path, '-a' ]
wormup_offset_s = 10
dateline_offset_h = 5

job_state = {
    'C': "Completed",
    'E': "Exiting",
    'H': "on Hold",
    'Q': "Queued",
    'R': "Recording",
    'T': "Moved",
    'W': "",
    'S': "Suspend",
}

def get_torque_job_info():
    jobs = {}
    present = datetime.datetime.now()

    #qstat -f -1でジョブ情報を取得し、２次元dictに詰める
    #jobs['jobid'][{"key": value, "key": value, ...}]
    #with open('qstat-f.job.all', 'r') as pjob:
    #    for jinfo in pjob:
    with subprocess.Popen(qstat, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as pjob:
        for jinfo in pjob.stdout:
    
            if re.match('Job Id:', jinfo):
                # a job informations begin here
                jid = re.search(r'^Job Id:\s*(\d+)\.', jinfo).group(1)
                jobs[jid] = {}
                jobs[jid]['JID'] = jid
                continue

            if re.search(' = ', jinfo):
                (jkey, jval) = jinfo.split(' = ')
                jkey = re.sub(r'\s', '', jkey)
                jobs[jid][jkey] = jval.rstrip()
            
    # ジョブごとに情報を追加
    for jid in jobs.keys():
        # ジョブ開始時間をjobs[jid]['rec_end']に登録する。
        if 'Execution_Time' in jobs[jid]:
            # 実行開始前(State: W)のジョブ。
            # 実行開始時間はqstat -fのExectiton_Timeから取得できる。
            # ex. "Tue Mar 15 23:59:50 2016"
            jobs[jid]['rec_begin'] = datetime.datetime.strptime(jobs[jid]['Execution_Time'], "%a %b %d %H:%M:%S %Y")
        elif 'start_time' in jobs[jid]: 
            # 実行中(State: R)、実行終了(State: C)のジョブ。
            # 実行開始時間はqstat -fのstart_timeから取得できる。
            # フォーマットはExecution_Timeに同じ。
            jobs[jid]['rec_begin'] = datetime.datetime.strptime(jobs[jid]['start_time'], "%a %b %d %H:%M:%S %Y")
        else:
            # ここに来るケースあるかしら？
            jobs[jid]['rec_begin'] = present;

        # ジョブ終了時間をjobs[jid]['rec_end']に登録する。
        # ジョブ開始時間 + Resource_List.walltime
        (wt_h, wt_m, wt_s) = jobs[jid]['Resource_List.walltime'].split(':')
        jobs[jid]['rec_end'] = jobs[jid]['rec_begin'] + datetime.timedelta(hours=int(wt_h), minutes=int(wt_m), seconds=int(wt_s))

        # タイトル、チャンネル番号を登録する
        (jobs[jid]['channel'], jobs[jid]['title']) = jobs[jid]['Job_Name'].split('.', 1)
        jobs[jid]['channel'] = re.sub('^ch[Bd]', '', jobs[jid]['channel'])

        # qstatのjob_stateをわかりやすい表記に
        jobs[jid]['record_state'] = job_state[jobs[jid]['job_state']]

        if jobs[jid]['job_state'] == 'R':
            # 録画開始からの経過時間を登録する
            elapse = (present - jobs[jid]['rec_begin']).seconds
            jobs[jid]['record_state'] = jobs[jid]['record_state'] + "({0:02}:{1:02}:{2:02})@{3}".format(
            int(elapse/60/60),int(elapse/60), elapse%60, re.sub('/.*$', '', jobs[jid]['exec_host'])
            )


    job_array = [jobs[x] for x in sorted(jobs.keys())]
    job_array = sorted(job_array, key=lambda j: j['rec_begin'])

    chech_channel_resource(job_array)

    return job_array

def chech_channel_resource(job_array):
    queue_info = get_queue_info()

    for job in job_array:
        if job['job_state'] == 'C':
            continue
        if len(queue_info[job['queue']]['jobs']) < queue_info[job['queue']]['ch_max']:
            # チャンネルの空きがある
            # queue_info[job['queue']]['jobs']にこのジョブを登録
            queue_info[job['queue']]['jobs'].append(job)
        else:
            # ガベージコレクト
            for old_job in queue_info[job['queue']]['jobs']:
                # queue_info[job['queue']]['jobs']に残っているジョブから録画終了しているものを削除
                if job['rec_begin'] > old_job['rec_end']:
                    queue_info[job['queue']]['jobs'].remove(old_job)

            # 改めてチャンネルの空き確認
            if len(queue_info[job['queue']]['jobs']) < queue_info[job['queue']]['ch_max']:
                # チャンネルの空きがある
                # queue_info[job['queue']]['jobs']にこのジョブを登録
                queue_info[job['queue']]['jobs'].append(job)
            else:
                job['alart'] = 'NoResource'

def get_queue_info():
    nodes = {}
    queue_info = {}

    # pbsnodes -qの出力から以下の情報を取得する。
    # ノード名
    # properties: そのノードの所属するキュー名
    # np:         チューナー数
    # state:      ノードの状態
    with subprocess.Popen(pbsnodes, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as pnodes:
        for ninfo in pnodes.stdout:
            if re.match(r'^\S+', ninfo):
                # a node informations begin here
                n = ninfo.rstrip()
                nodes[n] = {}
                continue
            if re.match(r'^\s+(state|np|properties) = \S+', ninfo):
                (key, value) = re.search(r'(state|np|properties) = (\S+)', ninfo).group(1, 2)
                nodes[n][key] = value

    # キューごとに、そのキューに所属するノードとチャンネル数を集計する。
    for node in nodes.values():
        if re.search(r'(offline|down)', node['state']):
            # 稼動状態にないノードは除外
            continue

        if not node['properties'] in queue_info:
            queue_info[node['properties']] = {}
            queue_info[node['properties']]['ch_max'] = 0
            queue_info[node['properties']]['jobs'] = []

        queue_info[node['properties']]['ch_max'] += int(node['np'])

    return queue_info

print('ID    Ch  Title                    Start           walltime user     queue')

job_array = get_torque_job_info()
prev_wday=''
for j in job_array:
    # 表示用に録画開始時刻マージン分を加算したdatetimeオブジェクトを作成
    begin = j['rec_begin'] + datetime.timedelta(seconds=wormup_offset_s)
    wday = begin.strftime("%a") if begin.hour >= dateline_offset_h else (begin - datetime.timedelta(days=1)).strftime("%a")
    mon  = int(begin.strftime("%m")) if begin.hour >= dateline_offset_h else int((begin - datetime.timedelta(days=1)).strftime("%m"))
    day  = int(begin.strftime("%d")) if begin.hour >= dateline_offset_h else int((begin - datetime.timedelta(days=1)).strftime("%d"))
    hour = int(begin.strftime("%H")) if begin.hour >= dateline_offset_h else int(begin.strftime("%H")) + 24

    if wday != prev_wday:
        print('----- --- ------------------------ --------------- -------- -------- -----')

    print('{0:5} {1:>3} {2:24} {3} {4:>2}/{5:2} {6:0>2}:{7:0>2} {8} {9:8} {10:5} {11}'.format(
    j['JID'], 
    j['channel'], 
    j['title'], 
    wday, 
    mon, 
    day, 
    hour, 
    begin.minute,
    j['Resource_List.walltime'], 
    j['euser'],
    j['queue'],
    j['record_state'],
    ), 
    end='')

    if 'alart' in j:
        print(' ({0})'.format(j['alart']))
    else:
        print()
    
    prev_wday=wday


# 確認(DEBUG)
#job_array = get_torque_job_info()
#for j in job_array:
#    for jkey in sorted(j.keys()):
#        print(jkey, ":", j[jkey])
#
#    print()

#queue_info = get_queue_info()
#for queue in queue_info.keys():
#    print(queue)
#    for v in queue_info[queue]:
#        print('    {0}  {1}'.format(v, queue_info[queue][v]))
